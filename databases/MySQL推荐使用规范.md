# 数据库环境

- dev：开发环境，开发可读写，可修改表结构。开发人员可以修改表结构，可以随意修改其中的数据但是需要保证不影响其他开发同事。
- qa：测试环境，开发可读写，开发人员可以通过工具修改表结构。
- sim：模拟环境，开发可读写，发起上线请求时，会先在这个环境上进行预执行，这个环境也可供部署上线演练或压力测试使用。
- real：生产数据库从库（准实时同步），只读环境，不允许修改数据，不允许修改表结构，供线上问题查找，数据查询等使用。
- online：线上环境，开发人员不允许直接在线上环境进行数据库操作，如果需要操作必须找DBA进行操作并进行相应记录，禁止进行压力测试。
- 这些环境的机器，一定要做到权限划分明确，读写帐号分离，并且有辨识度，能区分具体业务。例如用户名w_account，r_ account 分别代表读、写账号，account是读写账号。

# 表设计规范

- 表引擎取决于实际应用场景；日志及报表类表建议用myisam，与交易，审核，金额相关的表建议用innodb引擎。如无说明，建表时一律采用innodb引擎。[myisam与innodb的区别](http://www.biaodianfu.com/mysql-myisam-innodb.html)
- 使用`InnoDB`存储引擎:支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高;
- 推荐使用`utf8mb4`字符集,数据库排序规则使用`utf8mb4_general_ci`:无需转码，无乱码风险, 支持emoji表情以及部分不常见汉字;

    > MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在`utf8mb4`(最多4个字节)是`utf8`(最多3个字节)的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了。
    > 推荐: 为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8.  对于 `CHAR` `类型数据，utf8mb4` 会多消耗一些空间，根据 Mysql 官方建议，**使用 `VARCHAR`  替代 `CHAR`**。

- 表、字段必须加注释:方便他人理解字段意思，在后期维护中非常非常有用，不用去瞎猜这个字段是干嘛的;
- 不在数据库做计算:禁止使用存储过程、视图、触发器、Event。在并发量大的情况下，这些功能很可能将数据库拖跨，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”;
- 如无说明，表中的第一个id字段一定是主键且为自动增长，禁止在非事务内作为上下文作为条件进行数据传递。禁止使用varchar类型作为主键语句设计。
- 如无说明，表必须包含create_time和modify_time字段，即表必须包含记录创建时间和修改时间的字段;
- 如无说明，表必须包含is_del，用来标示数据是否被删除，原则上数据库数据不允许物理删除。
- 禁止存储文件:文件存储在文件系统，数据库里存URI;
- 控制单表数据量:单表记录控制在千万级;
- 用尽量少的存储空间来存数一个字段的数据:
    - 能用int的就不用char或者varchar
    - 能用tinyint的就不用int
    - 使用UNSIGNED存储非负数值。
    - 不建议使用`ENUM`、`SET`类型，使用`TINYINT`来代替
    - 使用短数据类型，比如取值范围为0-80时，使用TINYINT UNSIGNED
    - 存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE
    - 时间字段，除特殊情况一律采用int来记录unix_timestamp
        - 存储年使用YEAR类型。
        - 存储日期使用DATE类型。
        - 存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。
    - 建议使用INT UNSIGNED存储IPV4。
    - 尽可能不使用`TEXT`、`BLOB`类型,会浪费更多的磁盘和内存空间;
    - 禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。建议使用其他方式存储（TFS/SFS），MySQL只保存指针信息。
    - 单条记录大小禁止超过8k（`列长度(中文)*3(UTF8)+列长度(英文)*1`）
- 如无备注，所有字段都设置`NOT NULL`，并设置`默认值`；
- 禁止在数据库中存储明文密码
- 如无备注，所有的布尔值字段，如is_hot、is_deleted，都必须设置一个默认值，并设为0；
- 如无备注，排序字段order_id在程序中默认使用降序排列；
- 整形定义中不添加长度，比如使用INT，而不是INT[4]
- 使用VARBINARY存储大小写敏感的变长字符串
- 不要使用小数存储货币:建议使用整数，小数容易导致钱对不上;
- 使用`varchar(20)`存储手机号;

# 索引设计规范

MySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。合理的索引会加快查询速度（包括UPDATE和DELETE的速度，MySQL会将包含该行的page加载到内存中，然后进行UPDATE或者DELETE操作），不合理的索引会降低速度。MySQL索引查找类似于新华字典的拼音和部首查找，当拼音和部首索引不存在时，只能通过一页一页的翻页来查找。当MySQL查询不能使用索引时，MySQL会进行全表扫描，会消耗大量的IO。索引的用途：去重、加速定位、避免排序、覆盖索引。

## 索引基本规范

- 索引数量控制，单张表中索引数量不超过5个，单个索引中的字段数不超过5个。
    - 综合评估数据密度和分布
    - 考虑查询和更新比例
- 对字符串使用前缀索引，前缀索引长度不超过8个字符，建议优先考虑前缀索引，必要时可添加伪列并建立索引。
    - 不要索引blob/text等字段,不要索引大型字段,这样做会让索引占用太多的存储空间
- 主键准则
    - 表必须有主键
    - 不使用更新频繁的列
    - 尽量不选择字符串列
    - 不使用UUID MD5 HASH
    - 默认使用非空的唯一键
    - 建议选择自增或发号器
- 重要的SQL必须被索引，核心SQL优先考虑覆盖索索引
    - UPDATE、DELETE语句的WHERE条件列
    - ORDER BY、GROUP BY、DISTINCT的字段
    - 多表JOIN的字段
- 区分度最大的字段放在前面
    - 选择筛选性更优的字段放在最前面，比如单号、userid等，type，status等筛选性一般不建议放在最前面
    - 索引根据左前缀原则，当建立一个联合索引(a,b,c)，则查询条件里面只有包含(a)或(a,b)或(a,b,c)的时候才能走索引,(a,c)作为条件的时候只能使用到a列索引,所以这个时候要确定a的返回列一定不能太多，不然语句设计就不合理,(b,c)则不能走索引
    - 合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)
- 索引禁忌
    - 不在低基数列上建立索引，例如“性别”
    - 不在索引列进行数学运算和函数运算
    - 不要索引常用的小型表
- 尽量不使用外键
    - 外键用来保护参照完整性，可在业务端实现
    - 对父表和子表的操作会相互影响，降低可用性
    - INNODB本身对online DDL的限制

## MYSQL 中索引的限制

- MYISAM 存储引擎索引长度的总和不能超过 1000 字节
- `BLOB` 和 `TEXT` 类型的列只能创建前缀索引
- MYSQL 目前不支持函数索引
- 使用不等于 (`!=` 或者 `<>`) 的时候, MYSQL 无法使用索引。
- 过滤字段使用函数运算 (如 `abs (column)`) 后, MYSQL无法使用索引。
- `join`语句中join条件字段类型不一致的时候MYSQL无法使用索引
- 使用 `LIKE` 操作的时候如果条件以通配符开始 (如 ‘`%abc…`’)时, MYSQL无法使用索引。
- 使用非等值查询的时候, MYSQL 无法使用 Hash 索引。

# 命名规范

## 基本命名原则

- 库、表、字段使用英文**小写**单词，如果有多个单词则使用**下划线**隔开, 单词用单数, 避免保留字;
- 表、字段应该使用注释,描述该字段的用途及可能存储的内容;
- 命名禁止超过32个字符，须见名之意，建议使用名词不是动词
- 数据库，数据表一律使用前缀
    - 临时库、表名必须以`tmp_`为前缀，并以日期为后缀
    - 备份库、表必须以`bak_`为前缀，并以日期为后缀

## 表命名规范

- 同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义。所有日志表均以 log_ 开头
- 所有的表都必须有**备注**，写明白这个表中存放的数据内容；
- 预估表数据量，如果数据量较大（超过500w）则需要考虑分表策略。可以等量均衡分表或根据业务规则分表均可。要分表的数据表必须与DBA商量分表策略；
- 表名举例:
    1. user – 用户
    2. category – 分类
    3. goods – 商品、产品等一切可交易网站的物品都用此命名
    4. good_gallery – 物品的相册
    5. good_cate – 物品的分类，除了单独作为表名，其他地方分类单词一律用缩写cate
    4. attr – 属性
    5. article – 文章、新闻、帮助中心等以文章形式出现的，一般都用此命名
    6. cart – 购物车
    7. feedback – 用户反馈
    8. order – 订单
    9. site_nav – 包括页头和页尾导航
    10. site_config – 系统配置表
    11. admin – 后台用户 【RBAC标准表】
    12. role – 后台用户角色【RBAC标准表】
    13. access – 后台操作权限，相当于action【RBAC标准表】
    14. role_admin – 后台用户对应的角色【RBAC标准表】
    15. access_role – 后台角色对应的权限【RBAC标准表】
    16. 待续

## 字段命名规范

- 表的主键一般都约定成为id，自增类型；
- 把字段定义为`NOT NULL`并且提供`默认值`:
- 数值类型的字段请使用`UNSIGNED`属性并设置默认值0；
- 所有的布尔值字段，如`is_hot`、`is_deleted`，都必须设置默认值0；
- 各表之间相同意义的字段应同名。各表之间相同意义的字段，以去掉模块前缀的表名_字段名命名。
- 外键字段用`表名_字段名`表示其关联关系。尽量少用外键，如果有外键约束，用应用程序控制(外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能);
- 字段名举例:
    1. 表名_id – 通常用作外键命名
    2. cid – 特殊的编号，带有元数据，方便关联查询，你可以把它理解成类别(层次)编号。举个例子，产品在分类时，往往需要将其归类到子分类下，相应的字段中也一般只记录子分类的id，这时若需要知道该产品属于哪个主分类，就需要通过子分类信息再查询到主分类信息，这是比较麻烦的，cid字段就是要解决这个问题。一般的站点几十个分类肯定是够用了，所以这里假设某一主分类的cid为11，则子分类的cid从1101开始编号，处理时只需截取前两位数值便可知道该产品属于哪一个主分类了。
    3. add_time – 添加时间、上架时间等
    4. last_time – 最后操作时间，如登录、修改记录
    5. expire_time – 过期时间
    6. name – 商品名称、商家名称等，不要跟title混用，title只用于文章标题、职称等
    7. price – 价格
    8. thumb – 只要是列表页面中的窗口图，一律用此命名
    9. image_src – 相册中的图片地址一律用此命名，不要出现各种img,image,img_url,thumb_url等
    10. head_thumb – 用户头像， 虽然有点长，一定要遵守。不要出现上述情况
    11. image_alt – 相册中图片的alt属性
    12. desc – 描述、简介，比如goods_desc，不要出现goods_txt这种
    13. details – 详情、文章内容等
    14. order_id – 排序
    15. telephone – 座机号码
    16. mobile – 手机号码
    17. phone – 当不区分手机和座机时，请用phone命名
    18. address – 地址，单独出现不要用addr缩写，组合出现时需用缩写，比如mac地址，mac_addr
    19. zipcode – 邮编
    20. region – 地区，大的区域，比如记录杭州市、温州市等
    21. area – 区域，小的，比如上城区，江干区等
    22. avg_cost – 人均消费
    23. 待续

## 索引命名规范

- 非唯一索引必须按照“`idx_字段名称_字段名称[_字段名]`”进行命名
- 唯一索引必须按照“`uniq_字段名称_字段名称[_字段名]`”进行命名

## 约束命名

- 主键约束：`pk_表名称`。
- 唯一约束：`uk_表名称_字段名`。（应用中需要同时有唯一性检查逻辑。）

## 触发器命名

- trg_表名_操作。

## 函数过程命名

- 采用动词+名词的形式表达其含义。

## 序列命名

- seq_表名

# SQL语言编码规范

- 所有关键字必须大写，如：INSERT、UPDATE、DELETE、SELECT及其子句，IF……ELSE、CASE、DECLARE等;
- 禁止使用`SELECT *`，只获取必要的字段，需要显示说明列属性
    1. 消耗cpu，io，内存，带宽;
    1. 不能有效的利用覆盖索引;
    1. 使用`SELECT *`容易在增加或者删除字段后出现程序BUG, 不具有扩展性
- 使用`INSERT INTO t_xxx VALUES(xxx)`，必须显示指定插入的列属性:容易在增加或者删除字段后出现程序BUG
- 务必请使用“同类型”进行比较，否则可能全表扫面:`SELECT name FROM t_user WHERE phone=1888888888` 会导致全表扫描.
- 禁止在WHERE条件的上使用函数或者计算:
    - 解读：`SELECT naem FROM tuser WHERE date(createdatatime)='2017-12-29'` 会导致全表扫描;
    - 推荐的写法是：`SELECT name FROM tuser WHERE createdatatime>= '2017-12-29' and create_datatime <= '2017-12-30'`;
- 禁止负向查询，以及`%`开头的模糊查询:
    1. 负向查询条件：`NOT、!=、<>、!<、!>、NOT IN、NOT LIKE`等，会导致全表扫描;
    1. `%`开头的模糊查询，会导致全表扫描;
- 不要大表使用`JOIN`查询，禁止大表使用子查询:会产生临时表，消耗较多内存与CPU，极大影响数据库性能;
- `OR`改写为`IN()`或者`UNION`:原因很简单or不会走索引;
- 简单的事务:事务就像程序中的锁一样粒度尽可能要小;
- 不要一次更新大量数据:数据更新会对行或者表加锁，应该分为多次更新;

# 分表规范

单表一到两年内数据量超过500w或数据容量超过10G考虑分表，需提前考虑历史数据迁移或应用自行删除历史数据，采用等量均衡分表或根据业务规则分表均可。要分表的数据表必须与DBA商量分表策略

- 用HASH进行散表，表名后缀使用十进制数，下标从0开始
- 按日期时间分表需符合`YYYY[MM][DD][HH]`格式
- 采用合适的分库分表策略。例如千库十表、十库百表等
- 禁止使用分区表，分区表对分区键有严格要，分区表在表变大后执行DDL、SHARDING、单表恢复等都变得更加困难。
- 拆分大字段和访问频率低的字段，分离冷热数据

# 行为规范

- 批量导入、导出数据必须提前通知DBA协助观察
- 禁止在线上从库执行后台管理和统计类查询
- 禁止有super权限的应用程序账号存在
- 产品出现非数据库导致的故障时及时通知DBA协助排查
- 推广活动或上线新功能必须提前通知DBA进行流量评估
- 数据库数据丢失，及时联系DBA进行恢复
- 对单表的多次alter操作必须合并为一次操作
- 不在MySQL数据库中存放业务逻辑
- 重大项目的数据库方案选型和设计必须提前通知DBA参与
- 对特别重要的库表，提前与DBA沟通确定维护和备份优先级
- 不在业务高峰期批量更新、查询数据库其他规范
- 提交线上建表改表需求，必须详细注明所有相关SQL语句

#其他规范

日志类数据不建议存储在MySQL上，优先考虑Hbase或OceanBase，如需要存储请找DBA评估使用压缩表存储。