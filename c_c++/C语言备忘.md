

## 1 概述

### 开发环境

Visual Studio，优点：全能调试，开启速度较快，运行不怎么吃内存；缺点：安装包太大，安装过程超级慢， 而且会安装很多win组件，提示不怎么智能，只能在windows环境下使用。

Clion，优点：跨平台，习惯JB系IDE很上手无压力，更智能，安装方便；缺点：jvm系的软件普遍吃内存，启动超级慢（启动以后还好）。

另外，Visual Studio使用vc编译器，在Win环境下，配置无压力。在Windows环境下，Clion需要另外安装gcc编译器（推荐cygwin实现）。

I选择Clion。配置如下：

- 安装Clion-配置...

- 下载安装cygwin：
  在线安装，推荐源：http://mirrors.sohu.com/cygwin/，或者 https://mirrors.aliyun.com/cygwin/。

- 依次搜索`make gcc gdb`关键字，安装三个软件包。左上角依次搜索`make gcc gdb`，确保选中的是如图三个软件包就可以了：

  [![要不我们试试Windows下用CLion+Cygwin，顺便谈谈近态](https://www.bennythink.com/wp-content/uploads/2017/07/072217_1339_Windows2.jpg)](https://www.bennythink.com/wp-content/uploads/2017/07/072217_1339_Windows2.jpg)

- 打开Clion设置，配置Toolschains路径即可。

### 什么是C语言

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1535590861&di=4ba081514901915438d8d7f0e45d22d3&imgtype=jpg&er=1&src=http%3A%2F%2Fsydw.offcn.com%2Fuploadfile%2F2015%2F0525%2F20150525120644311.png)

语言的层次

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1535591042&di=78fdf44f9ed879b0786c394eaee747af&imgtype=jpg&er=1&src=http%3A%2F%2Fa0.att.hudong.com%2F07%2F86%2F01200000184904134390867172473_s.jpg)



### hello,world

```c
#include<stdio.h>  //宏（预编译）-包含头文件
int main() //从main开始从main结束
{
    /*在双引号中间输入Hello World*/ 
    printf("Hello World");
    return 0; 
}
/*注：
在最新的C标准中，main函数前的类型为`int`而不是`void`*/
```

### 格式化输出语句

格式化输出语句，也可以说是**占位输出**，是将各种类型的数据按照**格式化后的类型及指定的位置**从计算机上显示。

其格式为：`printf("输出格式符"，输出项)`;

| 转换说明 | 输出                                                         |
| -------- | ------------------------------------------------------------ |
| %a,%A    | 浮点数、十六进制数和p-计数法(C99)                            |
| %c       | 一个字符                                                     |
| %d       | 有符号十进制数                                               |
| %e,%E    | 浮点数,e计数法                                               |
| %f       | 浮点数，十进制计数法                                         |
| %g,%G    | 根据数值不同自动选择%f或%e,%e格式在指数小于-4或者大于等于精度时使用 |
| %i       | 有符号十进制整数(与%d相同)                                   |
| %o       | 无符号八进制整数                                             |
| %p       | 指针                                                         |
| %s       | 字符串                                                       |
| %u       | 无符号十进制数                                               |
| %x,%X    | 使用十六进制数0f的无符号十六进制整数                         |
| %%       | 打印一个百分号                                               |

| 标志   | 意义                                                         |
| ------ | ------------------------------------------------------------ |
| -      | 项目左对齐，即，会把项目打印在字段的左侧开始处示例: "%-20s"  |
| +      | 有符号的值若为正，则显示带加号的符号；若为负，则显示带减号的符号示例: "%+6.2f" |
| (空格) | 有符号的值若为正，则显示时带前导空格(但是不显示符号);若为负，则带减号符号。+标志会覆盖空格标志示例: "% 6.2f" |
| #      | 使用转换说明的可选形式。若为%o格式，则以0开始；若为%x和%Xgeshi ,则以0x或0X开始。对于所有的浮点形式，#保证了即使不跟任何数字，也打印一个小数点字符。对于%g和%G格式，它防止尾随0被删除示例: "%#o", "%#8.0f", "%+#10.3E" |
| 0      | 对于所有的数字格式，用前导零而不是空格填充字段宽度。如果出现-标志或者指定了精度(对于整数)则忽略该标志示例: "%010d", "%08.3f","%02X" |

注意：**格式符**的**个数**要与**变量、常量或者表达式的个数一**一对应

- 接受键盘输入：`scanf（“格式控制字符串”，地址表列）;`，如：`scanf(“%d%d%d”,&i,&j,&k);`.
- 单个字符输出getchar和输出putchar（stdio.h）。
- 字符串输入gets(string) 和输出puts(string)。
- `%p`与`%x`的区别：前者是输出的完整内存地址，后者输出是去除前面无效0的16进制数。
- `%-20d`表示：占用20个位置，并且靠左输出。

## 2 关键字-标识符

### 关键字

C语言的关键字共有32个，根据关键字的作用，可分其为数据类型关键字、控制语句关键字、存储类型关键字和其它关键字四类。

```
1 数据类型关键字（12个）： 
(1) char ：声明字符型变量或函数 
(2) double ：声明双精度变量或函数 
(3) enum ：声明枚举类型 
(4) float：声明浮点型变量或函数 
(5) int： 声明整型变量或函数 
(6) long ：声明长整型变量或函数 
(7) short ：声明短整型变量或函数 
(8) signed：声明有符号类型变量或函数 
(9) struct：声明结构体变量或函数 
(10) union：声明联合数据类型 
(11) unsigned：声明无符号类型变量或函数 
(12) void ：声明函数无返回值或无参数，声明无类型指针（基本上就这三个作用） 

2 控制语句关键字（12个）： 
A循环语句 
(1) for：一种循环语句(可意会不可言传） 
(2) do ：循环语句的循环体 
(3) while ：循环语句的循环条件 
(4) break：跳出当前循环 
(5) continue：结束当前循环，开始下一轮循环 
B条件语句 
(1)if: 条件语句 
(2)else ：条件语句否定分支（与 if 连用） 
(3)goto：无条件跳转语句 
C开关语句 
(1)switch :用于开关语句 
(2)case：开关语句分支 
(3)default：开关语句中的“其他”分支 
D 返回语句
return ：子程序返回语句（可以带参数，也看不带参数） 

3 存储类型关键字（4个） 
(1)auto ：声明自动变量 一般不使用 
(2)extern：声明变量是在其他文件正声明（也可以看做是引用变量） 
(3)register：声明积存器变量 
(4)static ：声明静态变量 

4 其它关键字（4个）： 
(1)const ：声明只读变量 
(2)sizeof：计算数据类型长度 
(3)typedef：用以给数据类型取别名（当然还有其他作用 
(4)volatile：说明变量在程序执行中可被隐含地改变
```

### 标识符

C语言规定，标识符可以是字母`(A～Z，a～z)`、数字`(0～9)`、下划线`_`组成的字符串，并且第一个字符必须是**字母或下划线**。在使用标识符时还有注意以下几点：

> 1. 标识符的长度最好不要超过8位，因为在某些版本的C中规定标识符前8位有效，当两个标识符前8位相同时，则被认为是同一个标识符。

1. 标识符是严格区分大小写的。
2. 标识符最好选择有意义的英文单词组成做到"见名知意"，
3. 标识符不能是C语言的关键字。

## 3 变量-常量

### 变量

变量就是可以变化的量，而每个变量都会有一个名字（标识符）。变量占据内存中一定的存储单元。**使用变量之前必须先定义变量**，要区分**变量名**和**变量值**是两个不同的概念。

![mark](http://myphoto.mtianyan.cn/blog/180604/fDe60DAAhb.png?imageslim)

> 变量定义的一般形式为：数据类型 变量名;

> 多个类型相同的变量：数据类型 变量名, 变量名, 变量名...;

![mark](http://myphoto.mtianyan.cn/blog/180604/G69bIBIKih.png?imageslim)

**注意:在定义中不允许连续赋值，如int a=b=c=5;是不合法的。**

变量的赋值分为两种方式:

1. 先声明再赋值
2. 声明的同时赋值

### 常量

在程序执行过程中，值不发生改变的量称为**常量**。

 C语言的常量可以分为**直接常量和符号常量。**

- 直接常量也称为

  字面量，是可以直接拿来使用，无需说明的量，比如：

  - 整型常量：13、0、-13；
  - 实型常量：13.33、-24.4；
  - 字符常量：‘a’、‘M’
  - 字符串常量：”I love imooc!”

![mark](http://myphoto.mtianyan.cn/blog/180604/aBEl71bIGE.png?imageslim)

在C语言中，可以**用一个标识符来表示一个常量，称之为符号常量。**符号常量在**使用之前必须先定义**。

常量的定义的两种方法：

```c
//方法1：
#define N 20 //通过宏的方式指定N为20，在预编译阶段进行替换
//方法2
const int N 20; //指定在程序中N的值为20，且程序本身无法更改。
```

#define 和 const的区别

- #define在程序编译之前（预编译）时把程序中所有的N进行替换。#define声明的常量没有内存地址（编译时没有变量N，便不会有N的内存地址，所以`&N`是错误的）。
- const在程序编译时把N声明为常量（不变量：不允许程序内部更改）。但是编译时N时有内存地址的（`&N`可以查到内存地址）。程序本身不能更改N指向的内存中的值，但是“外挂程序”可以直接修改内存的值。

- 在数组声明`int a[N]`时只能使用`#difine N 20`方式，`const int N = 20`会报错`variable-sized object may not be initialized`。进一步说明**const本质上还是可以改变的**。

## 4 数据类型

### 基本数据类型

C语言中，数据类型可分为：

1. 基本数据类型
2. 构造数据类型
3. 指针类型
4. 空类型四大类

![数据类型分类](http://upload-images.jianshu.io/upload_images/1779926-f6f534c323d98d96.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 整数类型

下表列出了关于标准整数类型的存储大小和值范围的细节：

| 类型           | 存储大小    | 值范围                                               |
| -------------- | ----------- | ---------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。

以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：![img](http://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg)

为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 **sizeof** 运算符。表达式 *sizeof(type)* 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：

#### 浮点类型

下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：

| 类型        | 存储大小 | 值范围                 | 精度      |
| ----------- | -------- | ---------------------- | --------- |
| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |
| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |

头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值：

**注：**

- char还可以有unsigned 和 signed之分，用来表示“数字”，也是占用1B。
- 计算机的数字分为定点数（整数：25；纯小数：0.265）和浮点数（25.256）；浮点数又分为float（4B）和double（8B）类型。
- `int` `short int` `long int`是**根据编译环境的不同，所取范围不同。**
- int在32bit、64bit windows系统中占用4B，同long类型；在16bit windows系统中占用2B，同shot类型。
- 而其中`short int`和`long int`至少是表中所写范围, 但是`int`在表中是以16位编译环境写的取值范围。
- 另外 c语言`int`的取值范围在于他占用的字节数 ，不同的编译器，规定是不一样。
- ANSI标准定义`int`是占2个字节，TC是按ANSI标准的，它的`int`是占2个字节的。但是在VC里，一个`int`是占4个字节的。

浮点数据是指带小数的数字。

> 生活中有很多信息适合使用浮点型数据来表示，比如：人的体重(单位：公斤)、商品价格、圆周率等等。

因为精度的不同又分为3种(float,double,long double)：

![浮点型](http://upload-images.jianshu.io/upload_images/1779926-a1d4e81d55244ac6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

注：**C语言中不存在字符串变量，字符串只能存在字符数组中,**这个后面会讲。

### 构造数据类型

> 后面还会详细介绍

结构数据类型允许构造由多个基础数据类型组合而成的复杂结构，结构数据类型为面向对象的蓝本。常用的构造类型有：数组、结构体struct、共用体union、枚举类型enum...

如果一个变量名后面跟着一个有数字的中括弧，这个声明就是[数组](https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97)声明。字符串也是一种数组，它们以ASCII的NUL作为数组的结束。要特别注意的是，方括内的索引值是从**0**算起的。

#### 字符串

C语言的**字符串**其实就是`char型数组`，所以使用字符串并不需要引用库。然而C标准库确实包含了用于对字符串进行操作的函数，使得它们看起来就像字符串而不是数组。使用这些函数需要引用[头文件](https://zh.wikipedia.org/wiki/%E6%A8%99%E9%A0%AD%E6%AA%94)`string.h`。

### 指针

> 后面还会详细介绍

如果一个变量声明时在前面使用 * 号，表明这是个指针型变量。换句话说，该变量存储一个地址，而 *（此处特指**单目运算符 \***，下同。C语言中另有双目运算符 * 表示乘） 则是取内容操作符，意思是取这个内存地址里存储的内容。把这两点结合在一起，可将 `int *a;`看作是 “*a 解得的内容类型为 int”，对更复杂的声明也如此[[注 1\]](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80#cite_note-8)。指针是 C 语言区别于其他同时代高级语言的主要特征之一。

指针不仅可以是变量的地址，还可以是数组、数组元素、函数的地址。通过指针作为形式参数可以在函数的调用过程得到一个以上的返回值（不同于`return z`这样的仅能得到一个返回值。

指针是一把双刃剑，许多操作可以通过指针自然的表达，但是不正确的或者过分的使用指针又会给程序带来大量潜在的错误。

例如：

```
int *pi;     // 指向整型数据的指针 pi
int * api[3];// 由指向整型数据的指针构成的数组，长度为 3
char ** argv;// 指向一个字符指针的指针
struct { int member; } stinst,
  * pst = & stinst;
// pst是一个指向一个匿名结构体的指针
```

储存在指针中的地址所指向的数值在程序中可以由 * 读取。例如，在第一个例子中， `*pi` 是一个整型数据。这叫做引用一个指针。

另一个运算符 `&`，叫做取地址运算符，它将返回一个变量、数组或函数的存储地址。因此，下面的例子：

```
int i, *pi; /* int and pointer to int */
pi = &i;
```

`i` 和 `*pi` 在程序中可以相互替换使用，直到 `pi` 被改变成指向另一个变量的地址。

当指针指向结构体时，可以使用运算符 -> 代替 *和. 的作用，如 `(*p).m` 与 `p->m` 等效。

### void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

| 序号 | 类型与描述                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | **函数返回为空** C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 **void exit (int status);** |
| 2    | **函数参数为空** C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 **int rand(void);** |
| 3    | **指针指向 void** 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 **void \*malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 |

如果现在您还是无法完全理解 void 类型，不用太担心，在后续的章节中我们将会详细讲解这些概念。

### 自动类型转换

数据类型存在自动转换的情况.
自动转换发生在**不同数据类型**运算时，在编译的时候**自动完成**。

![自动转换](http://upload-images.jianshu.io/upload_images/1779926-7a9c57f123a32025.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`char`类型数据转换为`int`类型数据遵循`ASCII`码中的对应值.

**注:**

> 字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换

> char可以转换为int，int可以转换为double，char可以转换为double。但是不可以反向。

### 强制类型转换

强制类型转换是通过**定义类型转换运算**来实现的。其一般形式为：

```
(数据类型) (表达式)
```

其作用是把表达式的运算结果强制转换成**类型说明符所表示的类型**

**在使用强制转换时应注意以下问题：**

1. 数据类型和表达式都必须加括号, 如把`(int)(x/2+y)`写成`(int)x/2+y`则成了把`x`转换成`int`型之后再除`2`再与`y`相加了。
2. **转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换**。
3. 强制转换后的运算结果**不遵循四舍五入**原则。

## 5 运算符

### C语言运算符

※ 算术运算符
※ 赋值运算符
※ 关系运算符
※ 逻辑运算符
※ 三目运算符

| ()、 []、 -> 、 .、 !、 ++、 --                          | 圆括号、方括号、指针、成员、逻辑非、自加、自减 |
| -------------------------------------------------------- | ---------------------------------------------- |
| ++ 、 -- 、 * 、 & 、 ~ 、 ! 、 + 、 - 、 sizeof、(cast) | 单目运算符                                     |
| * 、 / 、 %、==                                          | 算术运算符                                     |
| + 、 -                                                   | 算术运算符                                     |
| << 、 >>                                                 | 位运算符                                       |
| < 、 <= 、 > 、 >=                                       | 关系运算符                                     |
| == 、 !=                                                 | 关系运算符号                                   |
| &                                                        | 位与                                           |
| ^                                                        | 位异或                                         |
| \|                                                       | 位或                                           |
| &&                                                       | 逻辑与                                         |
| \|\|                                                     | 逻辑或                                         |
| ? :                                                      | 条件运算符（三目运算符）                       |
| = 、 += 、 -= 、 *= 、 /= 、 %= 、 &= 、 \|= 、 ^=       | 赋值运算符                                     |
| ,                                                        | 顺序运算符                                     |

比较特别的是，比特右移（>>）运算符可以是*算术*（左端补最高有效位）或是*逻辑*（左端补 0）位移。例如，将 11100011 右移 3 比特，算术右移后成为 11111100，逻辑右移则为 00011100。因算术比特右移较适于处理带负号整数，所以几乎所有的编译器都是算术比特右移。

### 运算符优先级

运算符的优先级从高到低大致是：单目运算符、算术运算符、关系运算符、逻辑运算符、条件运算符、赋值运算符（=）和逗号运算符。



## 6 语句

C程序的执行部分是由语句组成的。程序的功能也是由执行语句实现的。

C语句可分为以下五类：
```
1.表达式语句；
2.函数调用语句；
3.复合语句；
4.控制语句；
5.空语句。
```
### 表达式语句

```
表达式语句由表达式加上分号“；”组成。
其一般形式为：表达式；执行表达式语句就是计算表达式的值。
例如： x=y+z；a=520；赋值语句；
y+z；加法运算语句，但计算结果不能保留，无实际意义；
i++； 自增1语句，i值增1。
i++； 是先运算i后再加1。
++i； 是先把i值增1后运算。
```

### 函数调用语句

```
由函数名、实际参数加上分号“；”组成。
其一般形式为： 函数名(实际参数表) ；
执行函数语句就是调用函数体并把实际参数赋予函数定义中的形式参数，然后执行被调函数体中的语句，求取函数值。
调用库函数，输出字符串。
例如：
printf(a,b,c); /*调用名为"printf"的函数*/
```

### 复合语句

在程序中应把复合语句看成是单条语句，而不是多条语句。C语言中的复合语句（或称**语句块**）的格式为：

```c
{
x=y+z；
a=b+c；
printf(“%d%d”，x，a)；
}
//是一条复合语句。复合语句内的各条语句都必须以分号“；”结尾；此外，在括号“}”外不能加分号。
```

### 控制语句

#### 条件语句

C语言有两种条件语句形式，分别是`if`和`switch`。

If 的格式如下：

```c
if(運算式) // 如果
    语句; 
// 有时还会有 else：
else      // 否则
    语句;
```

表达式的值非零表示条件为真；如果条件为假，程序将跳过`if`处的语句，直接运行`if`后面的语句。但是如果`if`后面有`else`，则当条件为假时，程序跳到`else`处运行。`if`和`else`后面的语句可以是另个`if`语句，这种套叠式的结构，允许更复杂的逻辑控制流程得以实现。在一般情况下，`else`一定与最接近的`if`成对，因此常用括弧`**{}**`越过此限制。比较下面两种情况：

```
if(逻辑表达式)
    if (逻辑表达式)
        语句; 
    else
        语句;
if(逻辑表达式甲)
{
    if(逻辑表达式乙)
        语句;
}
else 
    语句;
```

要注意这里的缩进和换行只用于方便阅读。编译器并不会根据缩进层级猜测 if 和 else 的对应关系。

`switch`通常用于对几种有明确值的条件进行控制。它要求的条件值通常是整数或字符。与`switch`搭配的条件转移是`case`。使用`case`后面的标值，控制程序将跳到满足条件的`case`处一直往下运行，直到语句结束或遇到`break`。通常可以使用`default`把其他例外的情况包含进去。如果`switch`语句中的条件不成立，控制程序将跳到`default`处运行；如果省略`default`子句，则直接运行下一语句。`switch`是可以嵌套的。

```
switch(值)
{
  case 甲:
  case 乙:
    語句段1; // 甲乙都会执行
    // 更多语句…
    break;  // 跳转到 switch 末尾处
  case 丙:
    語句段2;
    break; 
  default:  // 无论如何都会匹配
    語句段3;
}
```

简单的条件判断也可用?:

```c
运算式?值1:值2;
如:
   a=b>c?b:c // 如果變數"b"的值大於變數"c" 把變數"b"的值賦予變數"a"
```

#### 循环语句

C语言有三种形式的循环语句：

```
do 
    語句
while(判断式); 

和:

while(判断式) 
    语句;

和:

for(起始化; 判断式;运算式)
    语句;
```

在`while`和`for`中，语句将运行到表达式的值为零时结束。在`do...while`语句中，循环将至少被运行一次。这三种循环结构可以互相转化：

```
for(起始化; 判断式;运算式)
    语句;
```

如果**语句**中不使用continue语句的话，相当于

```
初始化;
while (判断式) {
    语句;
    运算式;
}
```

当循环条件一直为真时，将产生[死循环](https://zh.wikipedia.org/wiki/%E7%84%A1%E7%AA%AE%E8%BF%B4%E5%9C%88)。

#### 跳转语句

跳转语句包括四种：`goto，continue，break和return`。

```
goto 标记;
```

`goto`语句是无条件转移语句，且标记必须在当前函数中定义，使用“标记:”的格式定义。程序将跳到标记处继续运行。由于`goto`（特别是向回 goto 和长距离的 goto）容易产生阅读上的困难，所以对新手应该尽量少用。[GCC](https://zh.wikipedia.org/wiki/GCC) 编译器拓展支持对指针 `goto`和宏内 goto，一定程度上增强了 goto 的可读性。

`continue`语句用在循环语句中，作用是结束当前一轮的循环，马上开始下一轮循环。

`break`语句用在循环语句或`switch`中，作用是结束当前循环，跳到循环体外继续运行。但是使用`break`只能跳出一层循环。在要跳出多重循环时，可以使用`goto`使得程序更为简洁。

当一个函数运行结束后要返回一个值时，使用`return`。`return`可以跟一个表达式或变量。如果`return`后面没有值，将运行不返回值。

### 空语句

空语句是什么也不执行的语句，一般由分号“；”或大括号"{ }"组成。

在程序中空语句可用来作空循环体，例如：

```c
while(getchar()!='\n');
//或：
while(getchar()!='\n') { }
```

本语句的功能是，只要从键盘输入的字符不是回车则重新输入,这里的循环体为空语句。

一般推荐使用大括号`{ }`来表示空语句，这样更直观。

## 7 函数

C语言的基本结构单位是函数。系统首先调用 main函数（主函数），通过函数的嵌套调用，再调用其他函数。函数可以是系统自带的函数，也可以是用户定义的函数。C语言中，不允许函数嵌套定义。

### 内存管理

C语言的特色之一是：程序员必须亲自处理内存的分配细节。

C语言使用栈（Stack）来保存函数返回地址／栈帧基址、完成函数的参数传递和函数局部变量的存储。 如果程序需要在运行的过程中动态分配内存，可以利用[堆](https://zh.wikipedia.org/wiki/%E5%A0%86)（Heap）来实现。

基本上C程序的元素存储在内存的时候有3种分配策略：

- 静态分配

如果一个变量声明为[全局变量](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F)或者是函数的[静态变量](https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F)，这个变量的存储将使用静态分配方式。静态分配的内存一般会被编译器放在[数据段](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%AE%B5)或[代码段](https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E6%AE%B5)来存储，具体取决于实现。这样做的前提是，在**编译时**就必须确定变量的大小。 以IA32的x86平台及gcc编译器为例，全局及静态变量放在数据段的低端；全局及静态常量放在代码段的高端。

- 自动分配

函数的自动局部变量应该随着函数的返回会自动释放（失效），这个要求在一般的体系中都是利用栈（Stack）来满足的。相比于静态分配，这时候，就不必绝对要求这个变量在**编译时**就必须确定变量的大小，**运行时**才决定也不迟，但是C89仍然要求在**编译时**就要确定，而C99放松了这个限制。但无论是C89还是C99，都不允许一个已经分配的自动变量运行时改变大小。

所以说**C函数永远不应该返回一个局部变量的地址**。

要指出的是，自动分配也属于动态分配，甚至可以用alloca函数来像分配堆（Heap）一样进行分配，而且释放是自动的。

- 动态分配

还有一种更加特殊的情况，变量的大小在运行时有可能改变，或者虽然单个变量大小不变，变量的数目却有很大弹性，不能静态分配或者自动分配，这时候可以使用[堆](https://zh.wikipedia.org/wiki/%E5%A0%86)（Heap）来满足要求。ANSI C定义的堆操作函数是malloc、calloc、realloc和free。

使用[堆](https://zh.wikipedia.org/wiki/%E5%A0%86)（Heap）内存将带来额外的开销和风险。

### main函数和其他函数

main函数可以没有返回值，无论类型是void还是int。

```c
void main(){
    getchar();
}
//或者如下:
int main(){
    getchar();
}
//或者如下(貌似这个才是最新的合乎规定的):
int main(){
    getchar();
}
```

非main函数,如果不是void类型,必须返回一个值,否则会有警告(C++会提示报错)

```c
int go(){
    getchar();
}
//会警告.
void go(){
    getchar();
}
//正确
```

### 函数的声明-定义

- 在调用一个函数之前,必须知道有这个函数存在,C语言从上往下开始编译,上面必须有函数的定义或者声明.

- 函数的声明可以有重复多个,但是函数的主题智能有一个.

  ```c
  void msg();  //函数的声明
  void msg();  //可以重复声明
  msg();  //函数的调用,调用之前必须先声明or定义.
  void msg(){
      ...;
  }			//函数的定义,只能唯一.	
  ```

### 形参-实参

函数的**形参和实参**具有以下特点：

- 形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。
- 函数调用的时候，形参分配内存；**新建一个变量**，存储传递过来的实际参数的值，等价于：实际参数给实际参数赋值，赋值时会自动进行数据类型的转换。
- 实参可以是常量、变量、表达式、函数等。
- 在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生**类型不匹配**的错误。

### 计算函数参数的顺序

无论是main函数、自定义函数，无论VC、gcc编译器。计算函数的参数的时候，一律是：从右向左。如：

```c
int main() {
    int num = 99;
    printf("%d, %d", num, ++num); //先计算++num
    return 0;
}
//会打印 100 100
```



### 全局变量-局部变量-块变量

C语言中的变量，按作用域范围可分为两种，即局部变量和全局变量。

- 局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。

- 全局变量也称为外部变量，它是在函数外部定义的变量。它不属于任何一个函数，创建全局变量比main函数还要早。它属于一个源程序文件。其作用域是整个源程序。全局变量的生命周期就是程序的生命周期。全局变量可以用于函数之间的通信。

- 在c++中可以在全局和局部都有`x`变量的情况下,可以使用`::x`访问全局变量。但是c语言不可以。

- 块语句内部的变量，作用域是整个块语句中`从开始定义的地方到块语句的结束`。同时包含里面包含是`子块语句`。即`块语句`和`子块语句`的作用域相当局部变量和`"子局部变量"`.

  ```c
  int a = 10;
  printf("%d\n", a);
  {
      int a = 5;
      printf("%d\n", a);
  }
  printf("%d\n", a);
  
  //会打印:
  10
  5
  10
  ```

### 函数返回值的声明周期

- 函数内部定义的**局部变量**，返回以后，变量就会被销毁，内存会会被回收。
- 倘若返回**全局变量**，全局变量会一直存在。
- 函数内部的**临时变量**（`return a + b`的`a+b`），保存在CPU寄存器，返回临时变量后，临时变量在寄存器中被销毁。
- 函数返回值有副本机制，返回的时候，原变量销毁之前，另外保存一份副本，以便于我们操作函数的返回值（副本）。
- 除了数组没有副本机制,其他数据类型都有；结构体变量有副本机制，结构体数组没有，结构体变量内部有数组也有副本机制。

### 变量存储类别

C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。

- 静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。
- 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。

C语言中存储类别又分为四类：

- 自动（auto）、
- 静态（static）、
- 寄存器的（register）
- 外部的（extern）。

1、用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式。如：

![auto](http://upload-images.jianshu.io/upload_images/1779926-daaf9ae04ad1961b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2、用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。如下为静态局部变量：

![static](http://upload-images.jianshu.io/upload_images/1779926-8a39a99966a4b26e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。

3、为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明。例如：

![register](http://upload-images.jianshu.io/upload_images/1779926-4a947ad73cae5ed8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

mtianyan: 注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；**局部静态变量不能定义为寄存器变量。**

4、用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。如：

![extern](http://upload-images.jianshu.io/upload_images/1779926-1f61bd0f51434925.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 内部函数与外部函数

- 在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为：
  static [数据类型] 函数名（[参数]）
- 这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。
- 在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为：
  extern [数据类型] 函数名([参数])
- C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。

静态变量只赋值一次

## 8 数组

### 一维数组

**数组概述**

数组在程序中是一块**连续的，大小固定并且里面的数据类型一致的内存空间**。

- 内存中连续存储；
- 大小固定；
- 元素具有相同的数据类型；

**声明一个数组：**

```
数据类型 数组名称[长度];
```

**初始化数组三种形式：**

数组初始化的本质：等价于对每一个元素进行赋值。

> 既然是赋值就有可能进行数据类型的转换。如：`double a[2] = {1, 2}`

```c
int a[5] = {1,2,3,4,5};
int a[] = {1,2,3,4,5,6,7};提供3个元素，数组长度为3。
int a[5]；a[0]=1;...a[4]=5;
//////////
int a[5] = {1,2,3};//正确，后面两个元素初始化为0
int a[] = {}; //错误，不知道几个元素，无法分配内存
```

- 数组在初始化的时候，数组内元素的个数不能大于声明的数组长度；其实可以越界，但是越界说明已经使用了不属于当前数组的内存区域（进程之间没有权限访问彼此的内存），就有可能导致访问内存没有权限导致程序崩溃。
- 如果采用第一种初始化方式，**元素个数小于数组的长度时，多余的数组元素初始化为0；**
- 在声明数组后没有进行初始化的时候，**静态（static）和外部（extern）类型的数组元素初始化元素为0**，自动（auto）类型的数组的元素初始化值不确定。

**读取数组元素**

如：数组 `int arr[3] = {1,2,3};` 那么arr[0]就是元素1。

**数组的遍历**

C语言中的**数组名在取值时代表数组的首地址**(但必须要记得的是，**数组名不是指针**)。

`a[i] `， 指向数组中的第 i+1 个元素（要记得数组下标是从 0开始算的）；
`*(a+i)`，指向从数组首地址（指向首个元素）开始数的第i个元素，也就是数组的第 i+1 个元素；

C 语言规定，`a[b]` 等价于 `*(a+b)`。然后加法是符合交换律的，所以它们又等价于 `*(b+a)` 及 `b[a]`。

地址同样：`&a[b]` 等价于`a+b`，等价于`b+a`，等价于`&b[a]`

so,如下四种遍历方式都是可以的：

```c
void main(){
	int a[] = {1,2,3,4,5};
	int i;

	for (i = 0; i<5; ++i) {
		printf("%5d", a[i]); //a[i]方式
		
		
	}
	printf("\n");

	for (i = 0; i<5; ++i) {
		printf("%5d", *(a+i)); //*(a+i)方式
		
		
	}
	printf("\n");

	for (i = 0; i<5; ++i) {
		printf("%5d", *(i+a)); //*(i+a)方式
		
		
	}
	printf("\n");

	for (i = 0; i<5; ++i) {
		printf("%5d", i[a]); //i[a]方式
		
		
	}
	printf("\n");
}
```

> 除了上面的下标遍历数组之外，for循环内部还可以通过指针的循环（`for (int *p; p<a+5; p++){...}`）来遍历数组。

注意以下几点：

1. 最好**避免出现数组越界访问**，循环变量最好不要超出数组的长度.
2. **C语言的数组长度一经声明，长度就是固定，无法改变**，并且**C语言并不提供计算数组长度的方法**。

由于C语言是没有检查数组长度改变或者数组越界的这个机制，可能会在编辑器中编译并通过，但是结果就不能肯定了，因此还是不要越界或者改变数组的长度

c语言获取数组长度

```c
int length = sizeof(arr)/sizeof(arr[0]);
```

**数组符号-指针**

如果定义了数组： `int a[3] = {1,2,3};` 则：

- `a`代表数组`a[]`的起始地址，说白了是一个**地址**； 
- `a[0]`代表`a数组`的第一个成员元素； 
- `a`等于`&a[0]`。

### 二维数组

**关于一维数组和二维数组区别**

- 一维数组在内存中是连续分布存储的，同样，二维数组也是在内存连续存储的。所以从内存的角度来分析，一维数组和二维数组其实没有本质区别。

- 二维数组可以使用一维数组来代替。但是在实际的应用中，有时候使用二维数组会更加直观，方便程序的编程。

- 二维数组`int a[2][5]`可以看作时两个一位数组`a[0][i]`和`a[1][j]`构成。

 

**二维数组的第一维和第二维概念**

- 例如 `int a[2][5]`中，前面的2表示第一维；后面的5表示第二维

- 二维数组的第一维表示最外部的那一层，第一维本身也是一个数组，里面存放了2个元素，这两个元素就分别是第二维的数组。第二维数组本身也是一个数组，里面存放的元素是普通的int型变量。

![img](https://images2015.cnblogs.com/blog/646301/201510/646301-20151025221810349-493374037.jpg)

**二维数组的下标访问**

```c
int a[2][5] = {{1,2,3,4,5},{6,7,8,9,10}};
int (*p)[5]; // 定义一个数组指针
p = a;

printf(" a[1][2]   = %d.\n", a[1][2]);     // a[1][2] = 8
printf("(*(p+1)+1) = %d.\n", *(*(p+1)+2)); // a[1][2]
///运行结果：
//a[1][2] = 8.
//(*(p+1)+1) = 8.
```

**二维数据符号-指针**

```c
1、a
2、a[0]等同于&a[0][0]
3、在数值上 a、&a、a[0]、&a[0]、&a[0][0] 是相等的，但是在类型上面是有区别的。

int a[2][5] = {{1,2,3,4,5},{6,7,8,9,10}};
printf("a        = %p.\n", a);        // a       类型是 int (*)[5]
printf("&a       = %p.\n", &a);       // &a      类型是 int (*)[2][5]
printf("a[0]     = %p.\n", a[0]);     // a[0]    类型是 int *
printf("&a[0]    = %p.\n", &a[0]);    // &a[0]   类型是 int (*)[5]
printf("a[0][0]  = %d.\n", a[0][0]);  // a[0][0] 类型是 int 
printf("&a[0][0] = %p.\n", &a[0][0]); // &a[0][0]类型是 int *
```

运行结果：
![img](https://images2015.cnblogs.com/blog/646301/201510/646301-20151025224238770-480593071.jpg)

 

**第一维和第二维的数组指针的使用**

```c
// 二维数组与指针的结合使用
int a[2][5] = {{1,2,3,4,5},{6,7,8,9,10}};

int (*p1)[5]; // 数组指针
int *p2;      // 一般指针
p1 = a;       // 等同 p1 = &a[0];     // 指向二维数组的数组名
p2 = a[0];    // 等同 p2 = &a[0][0];  // 指向二维数组的第一维数组

printf("a[0][2] = %d.\n", *(*(p1+0)+2));  // a[0][2] = 3
printf("a[1][2] = %d.\n", *(*(p1+1)+2));  // a[1][2] = 8
 
printf("a[0][2] = %d.\n", *(p2+2));       // a[0][2] = 3
printf("a[0][4] = %d.\n", *(p2+4));       // a[0][4] = 5
```

运行结果：
![img](https://images2015.cnblogs.com/blog/646301/201510/646301-20151025224713067-985100057.jpg)

 

**总结**

（1）需要理解二维数组的实质和几个符号的含义。

（2）二维数组和数组指针两者是有紧密的关系的。学会使用数组指针来操作二维数组，重在实践操作使用就会加深理解。



### 数组作为函数参数

- 数组当作参数时，传递的时指针：

```c
void change(int a[5]){  //传递的时指针（数组a的地址）
	printf("\n%p", a); 
	printf("\n%d", sizeof(a)); 
}

void main(){
	int a[5]={1,2,3,4,5};
	printf("\n%d", sizeof(a));
	change(a);
}
```

> - 数组数据拷贝非常浪费内存 ==》 **数组当作参数时，传递的是指针。操作的是原来的数组。**
> - **其他的数据类型在参数传递时，使用的时副本机制--即，新建内存空间。**



数组可以由整个数组当作函数的参数，也可以由数组中的某个元素当作函数的参数：

1. 整个数组当作函数参数，即把**数组名称传入函数**中，例如：

![数组参数](http://upload-images.jianshu.io/upload_images/1779926-5d8fd07b08fc49fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. 数组中的元素当作函数参数，即把数组中的参数传入函数中，例如：

![数组元素函数参数](http://upload-images.jianshu.io/upload_images/1779926-10fe0a8f4e7f62b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

数组作为函数参数时注意以下事项：

1. 数组名作为函数实参传递时，函数定义处作为接收参数的数组类型形参既可以指定长度也可以不指定长度。
2. 数组元素作为函数实参传递时，数组元素类型必须与形参数据类型一致。

### 字符串与数组

C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。一般有以下两种格式：

1. char 字符串名称[长度] = "字符串值";
2. char 字符串名称[长度] = {'字符1','字符2',...,'字符n','\0'};

注意：

1. []中的长度是可以省略不写的；
2. 采用第2种方式的时候最后一个元素必须是'\0'，'\0'表示字符串的结束标志；
3. 采用第2种方式的时候在数组中不能写中文。
   在输出字符串的时候要使用：`printf(“%s”,字符数组名字);`或者`puts(字符数组名字)`;。

### 字符串函数

常用的字符串函数如下(strlen,strcmp,strcpy,strcat,atoi):

![字符串函数](http://upload-images.jianshu.io/upload_images/1779926-7c371f16e70cf00a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

使用字符串函数注意以下事项：

1. strlen()获取字符串的长度，在字符串长度中是不包括‘\0’而且汉字和字母的长度是不一样的。比如：

![strlen](http://upload-images.jianshu.io/upload_images/1779926-e7b2d4ec00501917.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小，例如：

![strcmp](http://upload-images.jianshu.io/upload_images/1779926-b54dc80934c192aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝，比如：

![strcpy](http://upload-images.jianshu.io/upload_images/1779926-964f53a86fa3dcd8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. strcat在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串，如：

![strcat](http://upload-images.jianshu.io/upload_images/1779926-48e59caccbad53ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 多维数组

多维数组的定义格式是：
数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n];

![多维数组](http://upload-images.jianshu.io/upload_images/1779926-63ecf5e66c4f1280.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

定义了一个名称为num，数据类型为int的二维数组。其中第一个[3]表示第一维下标的长度，就像购物时分类存放的购物；第二个[3]表示第二维下标的长度，就像每个购物袋中的元素。

![矩阵](http://upload-images.jianshu.io/upload_images/1779926-5c20f4fb3bccb817.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

多维数组的初始化与一维数组的初始化类似也是分两种：

1. 数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = {{值1,..,值n},{值1,..,值n},...,{值1,..,值n}};
2. 数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值;

多维数组初始化要注意以下事项：

1. 采用第一种始化时数组声明必须指定列的维数。**mtianyan: 因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数；**
2. 采用第二种初始化时数组声明必须同时指定行和列的维数。

**二维数组定义的时候，可以不指定行的数量，但是必须指定列的数量**

> 二维数组定义的时候，可以不指定行的数量，但是必须指定列的数量。

### 多维数组的遍历

多维数组也是存在遍历的，和一维数组遍历一样，也是需要用到循环。不一样的就是多维数组需要采用嵌套循环

注意：多维数组的每一维下标均不能越界

### 综合练习：

```
#include <stdio.h>
#define N 10
//打印分数 
void printScore(int score[])
{
    int i;
    printf("\n");
    for(i=0;i<N;i++)
    {
        printf("%d ",score[i]);               
    }
    printf("\n");     
}
//计算考试总分 
int getTotalScore(int score[])
{
    int sum = 0;
    int i;
    for(i=0;i<N;i++)
    {
        sum+=score[i];                
    } 
    return sum;
}
//计算平均分 
int getAvgScore(int score[])
{
    return getTotalScore(score)/N;   
}
//计算最高分 
int getMax(int score[])
{
    int max = -1;
    int i;
    for(i=0;i<N;i++)
    {
        if(score[i]>max)
        {
            max = score[i];              
        }                
    } 
    return max;
}
//计算最低分 
int getMin(int score[])
{
    int min =100;
    int i;
    for(i=0;i<N;i++)
    {
        if(score[i]< min)
        {
            min = score[i];              
        }                
    } 
    return min;
}
//分数降序排序 
void sort(int score[])
{
    int i,j;
    for(i=N-2;i>=0;i--)
    {
        for(j=0;j<=i;j++)
        {
            if(score[j]<score[j+1])
            {
                int temp;
                temp = score[j];
                score[j] = score[j+1]; 
                score[j+1]=temp;                  
            }                 
        }                   
    }
    printScore(score);     
}

int main()
{
    int score[N]={67,98,75,63,82,79,81,91,66,84};
    int sum,avg,max,min;
    sum = getTotalScore(score);
    avg = getAvgScore(score);
    max = getMax(score);
    min = getMin(score);
    printf("总分是：%d\n",sum);
    printf("平均分是：%d\n",avg);
    printf("最高分是：%d\n",max);
    printf("最低分是：%d\n",min);
    printf("----------成绩排名---------\n");
    sort(score);
    return 0;    
}
```

## 9 指针

**指针**是一个**变量**（类型：`int *`...），其值为另一个变量的**地址(常量)**，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。

指针的两个属性：**指向的首地址**、**指针的类型**：

- 指向的首地址：决定了 `*p` 从哪儿开始读取；

- 指针的类型：决定了**指向数据的大小**及**解析方式**（如：`int *p` 和 `char *p`）。 如：

  ```c
  //数据类型的强制转换时，如下：
  int *p;  //p是一个指针变量
  char *pp;
  p = (int *)0X42B628;  //强制转换地址为指针变量时，需要指定指针的类型 int *
  pp = (char *)0X42B660;
  ```

- **指针的类型必须要与指针指向的类型一致**，否则会出现偏差。如：

  ```
  int a = 12;
  int *p = &a;
  // int * 类型的指针 和 int 类型的数据 一致。 
  ```

>  C语言有很多数据类型，有保存数据、字符...的，但是如何保存**内存中某个存储单元的（起始）地址（编号）**呢？**指针（变量）便是这个特殊的数据类型**。

- `&`:取址：根据内存区域（变量），读取某内存区域的地址。
- `*`:取值：根据内存地址，取出对应区域的内容。

```c
// 指针变量声明的一般形式为：
int a = 1;
int *p = &a;  //声明指针变量p
// p的类型为 “指针类型” ：  int *
// *p == a
// p == &a
// int 存在的必要性：p只是a的首地址&a，有int才能知道截取4Byte，且按照int类型解析；
// int p = &a; 不合理！ 其中 &a 的值为 0xffffcbec（类型：内存地址） ，把内存地址赋值给int类型的p就“不合理”。
```

**指针的必要性**

如下代码说明：子函数可以访问父函数的变量，但是另辟内存空间，不能修改父函数的变量。

通过**指针**可以实现：修改父函数的变量，

> 指针可以在函数内部修改外部的变量。

```c
#include <stdio.h>

void child(int b) {
    // 能访问父函数变量a的值，但是另辟内存空间。
    b -= 1;
    printf("子函数数据：%d 子函数地址：%p", b, &b);
    printf("\n");
}
//形参会临时开辟新的空间，创建新的变量容纳实际参数，子函数结束，内存空间回收。

int main() {
    int a = 100;
    printf("父函数数据：%d 父函数地址：%p", a, &a);
    printf("\n");
    child(a);//调用子函数
    printf("父函数数据：%d 父函数地址：%p", a, &a);
}
//结果：
//父函数数据：100 父函数地址：0xffffcbfc
//子函数数据：99 子函数地址：0xffffcbd0
//父函数数据：100 父函数地址：0xffffcbfc
```

排序后输出-不改变原变量的值

```c
if (*pa > *pb) {
    int *pt = pa;  //通过交换指针（指向），来输出。
    pa = pb;
    pb = pa;
}
printf("%d, %d", *pa, *pb);
```



使用指针的代码如下：

```c
#include <stdio.h>

void child(int *p) {
    // 能访问父函数变量a的值，但是另辟内存空间。
    *p = 99;
    int b = *p;
    printf("子函数数据：%d 子函数地址：%p", b, &b);
    printf("\n");
}

int main() {
    int a = 100;
    printf("父函数数据：%d 父函数地址：%p", a, &a);
    printf("\n");
    child(&a);//调用子函数
    printf("父函数数据：%d 父函数地址：%p", a, &a);
}
//结果：
//父函数数据：100 父函数地址：0xffffcbfc
//子函数数据：99 子函数地址：0xffffcbbc
//父函数数据：99 父函数地址：0xffffcbfc
```



把一个内存地址直接赋值给指针变量：`int *p = (int *)0xffffcbfc`（注意两边的类型要匹配）。

但是一个exe不能读取另外一个exe的内存（以前的win98可以访问，所以win98容易死机）。

Windows内部进程之间不能直接访问。

想要实现修改另外一个程序的内存，方式如下：

```c
//不使用main函数，函数添加头部：_declspec(dllexport)
//_declspec：声明此函数可以被外部调用；
//（dllexport） dll的导出
_declspec(dllexport) int go() {
    ...
}
// 编译成dll，然后使用dll注入工具（如：DllInject）注入即可。
```



在32bit的编译器（不等于系统）中，指针变量占用4B；



指针变量的声明

```c
double *pa, pb, pc;  //pa是指针变量，pb、pc是double变量
int *p = NULL;  //空指针
int *p; //错误！！习惯不好。声明指针p后没有初始化，会成为野指针。指针定义之后就赋值是个好习惯
//野指针指向的内存是随机的。定义之后赋值，不用之后用NULL绑定它。要不会有可能出错，或者自己误操作这个野指针。疯狗乱咬人，就是没碰见。

```

指针不可以乱指，否则指向其他进程的内存区域，会因为无权访问造成程序崩溃。

空指针

```c
int *p = NULL;  //空指针的内容为0
//使用场合：
if (p == NULL) {  //检查指针是否本占用，如果占用小心使用。
    ...
}
```

> Null，本意是"空的，元素只有零的"意思。NULL和0的值都是一样的，但是为了目的和用途及容易识别的原因，NULL用于指针和对象，0用于数值。



直接访问-间接访问

按照C的方式，如果定义一个变量，系统会给这个变量分配一块**内存**，变量有*两个属性*，**变量值**和**变量地址**。变量地址指示了该变量在内存中的存储位置，变量值是这块内存中的内容。

- 直接访问：要访问这块内存空间上的内容，可以直接使用变量名。
- 间接访问：间接访问的含义是先从**其它内存空间**获得要访问的内存地址，根据得到的地址访问目的地址。
- 直接访问用于自己的程序；间接访问用于外挂。

```c
int num = 1;
print("%d", num);  //直接访问
int *p = &num;
print("%d", *p);  //间接访问
```

### 指针-函数参数

```c
//void change(int num){   //形参会新建一个变量来接受实参，不会改变实参。
//	num = 9;           
//}

void changep(int *p){   //声明一个指针变量p，接受一个地址参数
	*p = 9;            //改变地址指向的内存的值
}

void main(){
	int num = 10;
	change(&num);  // 传入地址参数，调用函数
	printf("%d", num);
}
```

>函数调用时：
>
>- 传入参数为原来数据的**地址** ==》 改变原来的数据；
>- 传入参数为原来的**数据** ==》 不改变原来的数据；

>- C语言函数参数传递时采用副本机制，新建变量来接受实参，函数调用结束后，变量销毁 ==》 不会修改原函数实参的值。**但是，数组例外！！见下一条：**
>- 数组的拷贝太耗内存，所以数组当作函数的参数传递时`void change(int a[5]){...}`传入的指针（即，原数组的地址），操作的也是原数组（并没有采用副本机制）。
>- C语言要**改变外部变量**只能传地址，Java，C++有`引用`(`void chang(int & num)`)可以改变外部变量，但是C语言没有。

### 指向指针的指针

> 定义一个变量，系统会给这个变量分配一块**内存**，变量有*两个属性*，**变量值**和**变量地址**。变量地址指示了该变量在内存中的存储位置，变量值是这块内存中的内容。
>
> 变量名临时保存在编译器的“符号表”中，编译之后，不存在变量名，只有对应的相对地址。

指针变量也是变量，占据内存空间，因此可以用另一个指针指向当前指针。称作：二级指针 or 指向指针的指针。

上面已经得知，想改变一个外部变量：

- 如果是数据，传递数据的地址（指针）；
- 如果是指针，传递指针的地址（二级指针）；

```c
double a = 1.1;
double b = 2.2;

void changep(double **pp){  //传入二级指针pp
	*pp = &b;  //修改pp的值，即指针p的地址。
}

void main(){
	double *p = &a;
	double **pp = &p;
	printf("\n%f, 指针p指向的地址：%p", *p, p);
	changep(pp);
	printf("\n%f, 指针p指向的地址：%p", *p, p);
}
//结果：
//1.100000, 指针p指向的地址：0042B628
//2.200000, 指针p指向的地址：0042B630
```

> 注意理解：
>
> - `pp` :二级指针pp的值，等价于&p，即指针p的地址。
> - `*pp` : 指针p的值，等价于&a，即a的地址。
> - `**pp` : a的值。
> - `p` : 指针p的值，等价于&，即a的地址。
> - `*p` : a的值。
> - `&p `: 指针p的地址，等价于二级指针pp。

二级指针使用场景：

- 函数内部改变外部的指针变量。
- 游戏外挂改变外部的指针变量。

### 指针类型-所指向的类型

- 指针类型：声明指针变量时位于变量名前的`类型 *`，如：`int *p` 、` char **p`。
- 指针所指向的类型：为指针初始化或赋值的变量的类型。
- **指针的赋值只是（首）地址的赋值**，指针的类型决定了读取长度、解析的方式。

原则上说:

- 指针类型和指针所指向的类型应当是相同的。
- 不是同一个类型的指针，不可以随意赋值。

```c
ch = 'A';
char *p1, *px;  //指针类型： char * ；找到首地址，读取1B
int *p2;  //指针类型： int * ；找到首地址；读取4B
double *p3;  //指针类型： double * ；找到首地址；读取8B
p1 = &ch;
px = p1; //指向的首地址赋值。二者都是 int * 类型的指针，不会出错。
//px p1 两个指针都指向了&ch,修改 *px 会修改 *p1 的值，反之亦然。 ch == *p1 ==*px
p2 = p1; //可以编译通过，但是会出错。p2 指向 ch 首地址，但是会解析4B,而不是1B。*p2 的结果就不得而知了。
// 不是同一个类型的指针，不可以随意赋值。
```

### 指针变量的值

指针变量的值：指针本身存储的数值，这个值将被编译器当作一个地址，而不是一般的数值。

> 可以这么理解：一般的变量（int shot char...）可以用一边变量表示。但是**地址这个特殊的变量**需要**指针变量**来表示。

32bit的编译器中，**所有类型的指针的值都是一个32bit的整数**（因为：内存地址长度为32bit）。

```c
//数据类型的强制转换时，如下：
int *p;  //p是一个指针变量
char *pp;
p = (int *)0X42B628;  //强制转换地址为指针变量时，需要指定指针的类型 int *
pp = (char *)0X42B660;
```

### 指针的运算

作为一种特殊的变量，指针可以进行一些运算，但并非所有的运算都是合法的。指针的运算主要为：赋值运算、局限的加减运算、其他一些为数不多的特殊运算（关系运算等）。

- 指针变量的赋值运算

```c
p = &a;  //变量a的地址==》p，地址的赋值
p = array;  //数组array首地址==》p
p = &array[1];  //数组元素地址==》p
p1 = p2;  //指针变量p2的值==》p1，指针的赋值
```

- 指针变量的算术运算

指针的算术运算并不是地址加减一个B（指向上/下一个内存空间）。而是根据指针的类型不同加减对应的B。

如：`int *` 加减4B，`char *` 加减1B。

```c
int a[] = {1,2,3,4,5};
int *p = a;//p指向数组a的首地址
p++ //根据 int * 类型加 4B 指向第二个元素。
p-- //同样
```

- 指针变量的关系运算

只有当两个指针指向同一个数组中的元素时，才能进行关系运算。 其他情况的关系比较毫无意义（在内存中存储的位置不同而已）。

当指针p和指针q指向同一数组中的元素时，  则： （可以用在if判断里面作为条件）

```c
p<q 当p所指的元素在q所指的元素之前时，表达式的值为1；反之为0。 
P>q 当p所指的元素在q所指的元素之后时，表达式的值为1；反之为0。 
p==q 当p和q指向同一元素时，表达式的值为1；反之为0。 
p！=q 当p和q不指向同一元素时，表达式的值为1；反之为0。
```

### 指针与数组

**指针-二维数组**

```c
#include <stdio.h>
#include <stdlib.h>

void main(){
	int a[] = {1,2,3,4,5};
	printf("%p\n%p\n%p", a,&a,*a);
    //a是一个指向int类型数据（单个元素）的指针，占4B
    //&a是一个指向数组（5个元素）的指针，占20B
    //*a是指向第一个元素，占4B
	printf("\n%d, %d",sizeof(*a), sizeof(*&a));
	
}
//结果：
//0019FF2C
//0019FF2C
//00000001
//4, 20
```

**指针-高维数组**

```c
#include <stdio.h>
#include <stdlib.h>

void main(){
	int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
	printf("%p\n%p\n%p", a,&a,*a);
    //a是一个行指针，指向一个有四个元素的数组，占16B
    //&a是一个指向二维数组（12个元素）的指针，占48B
    //*a是一个指向int类型数据（单个元素）的指针，占4B
	printf("\n%d, %d, %d",sizeof(*a), sizeof(*&a),sizeof(**a));
}
//结果：
//0019FF10
//0019FF10
//0019FF10
//16, 48, 4
```

其他知识点待续....如：`a[2]`相关代表什么？

### 数组-函数参数

可以用指向数组的指针作为函数的参数。

```c
void showa(int a[]){
	int i = 0;
	for (; i<5; i++){
	printf("%d\n", a[i]);
	}
}

void main(){
	int a[5] = {1,2,3,4,5};	
	showa(a);  //调用showa函数是，传入指向数组的指针a。
}
```



### 指针常量-常量指针

- 常量指针

常量指针本质是指针，常量修饰它，表示这个指针是一个指向常量的指针（变量）。指针指向的对象是常量，那么这个对象不能被更改。

在C/C++中，常量指针是像这样声明的：

```c
const int *p; //或者
int const *p;
*p = xxx; //错误，*p（指向的对象）是常量不能修改。
```

常量指针**指向的对象**由于有`const`属性， 无法直接改变， 但是指针本身值(及指针指向的内存地址)可以改变

- 指针常量

指针常量表示一个指针本身为常量及指针本身带有const属性，声明如下：

```c
int *const p;
p = &xxx; //错误，指针p为常量不能修改。
```

指针常量则是**指针本身**有`const`属性， 指针的值(及指针指向的内存地址)无法直接改变， 而该地址内的变量可以改变。

### 指针与整数

无论指针指向什么类型的两，对于32bit的编译器来说，指针的值（本身）都占据4B，指针的值是每个内存的地址，这应当是个“整数”。

如果实在有必要对某个内存的地址进行访问，可以通过强制类型转化来完成，如：

```c
int *pNum = (int *)0x0012ff7c
```

### 函数指针

- 函数的本质：如果在程序中定义了一个函数`int add(int a, int b);`，在编译时，编译系统为函数代码分配一段存储空间，然后用函数名`add`来指向这个地址。

- 函数调用本质：反编语言后，会发现：在调用函数时，其实是调用`jmp`函数（类似c语言的`goto`函数），即，**`jmp`(跳转)到另一个内存地址（函数的入口点）继续执行程序**。

- 可以这样理解，函数名就像数组名一样，只不过函数名是代码段的指针，而数组名是数据段的指针。

- 函数指针：既然函数在内存中有一个起始地址，我们用一个指针变量指向这个起始地址，便是这个函数的指针。

- 函数指针的定义：把**函数声明**时`int add(int a, int b);`的函数名`add`用 `(*p)` 代替即可`int add(int a, int b);`，`p`为函数指针名。另外函数指针的定义时，参数可以省略，就有：`int add(int, int);`

- 函数指针的用途：可以对函数的地址进行相应的传递、操作。

  - 通过其他函数名调用函数。

  - 作为参数传递到其他函数。如：`int run(int a, int b, int (*operator)(int, int);)`，run函数的参数为两个整数和一个操作函数。
  - 制作外挂等等。

```c
void msg(){  //定义函数msg
	MessageBoxA(0,"Fuck you!","Get out!!",0);
}

int add(int a, int b){  //定义函数add
	return a + b;
}

void main(){
	msg();  //调用msg
	printf("%d\n", add(1, 10));  //调用add并打印
	printf("%x,\n%x\n", add, msg);  //函数名保存的时函数的起始地址

}

void (*p)() = msg;  //定义指针并初始化为 msg 
   // 可以先声明在初始化： p = msg;
p();  // 通过指针来执行函数

int (*pp)(int a, int b);  //定义函数指针：把 add 用 (*p) 代替；
//int (*pp)(int, int);  //省略参数也可
pp = add;
```

### 函数的返回值是指针

`int go();`定义的函数go返回值类型是`int`；

那么，`int * go();`定义的函数go返回值类型便是`int *` ，即指针。



```c
int a = 10;
int b = 20;

int * go(){  //函数go的返回值是一个指针。指针的类型为： int *
	return &a;
}
void main(){
	printf("%d", *(go()));  //打印函数返回值  的内容
}
```

### void类型的指针

空类型指针可以指向任何类型的数据，用于保存地址。

即，空类型指针可以指向任何类型的首地址，但是并不明确需要读取、解析多少个字节。

```c
char ch = 'A';
int num = 100;
double db = 10.9;
void *p; //定义空类型指针。
p = &ch;
p = &num;
p = &db;  //可以指向任地址。
printf("%f", *((double *) p));  //但是在调用时必须明确指针的类型 
//强制转换指针的类型： (double *) p
```

### malloc/free函数

`malloc()`函数使用来动态分配内存空间，`free()`用来释放内存空间，两者搭配使用，若忘记free，则可能引起内存泄漏。

- `malloc()`函数的原型为：`void *malloc(long NumBytes)`，参数为内存的大小，返回值为void类型的指针（这一片内存的地址）。
- `free()`函数的原型为：`void free(void *FirstByte)`，参数为目标内存区域的首地址，返回为空。

```c
#include <stdlib.h>

void main(){
    int *p = (int *) malloc(sizeof(int)); 
    //分配一个元素大小的内存malloc(sizeof(int))
    //并强制把 void 类型的指针，转换为 int * 类型的指针
    //赋值给 p 指针。
    *p = 5; //对p指向的内存区域赋值
    printf("我有%d元", *p);
    free(p); //释放p指向的内存区域。    
}
```

利用malloc动态分配内存：

```c
#include <stdio.h>
#include <stdlib.h>
void main(){
	int x;
	scanf("%d", &x);
    int *p = (int *) malloc(x*sizeof(int)); //动态分配内存
    
    //下标法：以数组的方式来访问
	//for (int i = 0;i < x;i++){
	//	p[i] = i + 1;  //初始化
	//	printf("\n%d,%x", p[i], &p[i]);
	//}
    
    //指针法：
    for (int *px = p, i = 0;px < p + x; px++, i++){
        *px = i + 1;
        printf("\n%d, %x", *px, px);
    }
	getchar();
}
```

除了malloc动态分配内存之外，我们可以使用calloc和ralloc，malloc和calloc对比如下：

ralloc用于把之前分配的内存区域的内容复制，然后再重新分配的更大内存空间，把之前复制的内容粘贴后，再进一步动态分配。使用场景：之前分配的内存区域后面的区域被其他程序占用。

```c
int *p = (int *) malloc(x*sizeof(int)); 
int *p = (int *) calloc(x, sizeof(int)); //第一个参数是个数，第二个参数是大小

```

### 迷途指针

迷途指针：创建指针指向一块区域，当这块区域的内容被回收时，此时的指针依然指向这块被回收的地址（垃圾数据），此时的指针称作迷途指针。

当指针不指向特定的内存区域时，应当清空指针(`p = NULL;`)。

```c
int *p = (int *) malloc(x*sizeof(int)); //p指向一块区域
//下标法：以数组的方式来访问
for (int i = 0;i < x;i++){
	p[i] = i + 1;  //初始化
	printf("\n%d,%x", p[i], &p[i]);
}
free(p);  //释放p指向的这块区域
//虽然p指向的区域已经被系统回收，但是p还是指向这块区域（垃圾数据）。
p = NULL;  //把指针也清空--正确的做法
```



## 10 字符串

字符串就是 char 数组。



字符串不可以用 `=` 赋值。

字符串的初始化有两种方式：

```c
#include <stdio.h>
#include <string.h>

char str[];
//方式1：sprintf
sprintf(str, "ABC");  //把 “ABC”打印给str，在stdio.h中

//方式2：strcpy
strcpy(str, "ABC");  //把 “ABC”复制给str，string.h中
```



## 11 结构体-共用体-typedef

C 数组允许定义可存储相同类型数据项的变量，**结构**是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

> - 结构体数据类型，和 `int`、`char` 、`数组` 是一个级别的。
>
> - 先定义结构体类型，然后再创建特定的结构体变量。
> - 结构体不同于函数，函数可以先在main函数上面声明，然后再main函数后面定义。但是结构体只能在 main函数前/内 定义，才能被正常引用。
> - 结构体在定义时不会分配内存，只有在创建具体的结构体变量时才会分配内存。

### 结构体类型/实例的定义

结构体定义的第一种形式：

```c
//定义结构体类型nameinfo，并没有分配内存。
struct nameinfo {   //struct是关键词-不能省略；
    				//nameinfo为结构体名-可以省略=》无名结构体
    char name[50];  //成员类型可以是基本类型or构造类型
    char phone[50];
    int num;
};

//创建/定义两个结构体变量myinfo，此时才分配内存：
struct nameinfo myinfo1, myinfo2; //struct不能省略。struct nameinfo 类似于 int，是一个数据类型。

//对结构体变量内部的元素进行访问、赋值
myinfo.num = 100;
```

结构体定义的第二种形式：

```c
#define DD struct nameinfo

DD {
    ...;
};

DD myinfo1, myinfo2; 
```

结构体定义的第三种形式：

```c
struct nameinfo {   
    ...;
}myinfo1, myinfo2;
//  定义类型的同时，直接创建变量。
```

### 结构体实例的初始化

```c
struct nameinfo {   
    ...;
};
struct nameinfo myinfo1 = {"王五",1321124521,25};

//或者：
struct nameinfo {   
    ...;
}myinfo1 = {"王五",1321124521,25};

//或者：
struct {  //无名结构体   
    ...;
}myinfo1 = {"王五",1321124521,25};
```

### typedef

typedef为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 **BYTE**：

```c
//使用1：
typedef unsigned char byte;  //unsigned char 类型的别名：byte

//使用2：
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;  // struct Books 类型的别名为 Book

//或者：
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} ;  //定义结构体类型
typedef struct Books Book；//  struct Books 别名为 Book
```



### 结构体-数组

结构体中可以有数组类型的成员，数组的元素也可以是结构体。数组和结构体的初始化是一样的，都是把各个元素放在一个大括号里，各个成员用逗号分隔。

```c
#include<stdio.h>
#include<string.h>
 
int main()
{
	struct student
	{
		int  number;
		char name[20];
		char sex;
		int  age;
		char addr[30];
	};
 
	//定义数组的同时，对数组前2个元素（结构体）进行了初始化
	struct student s[3] = { {10000,"Zhang",'m',21,"Shang Hai"},
		                {10001,"Li",'f',20,"Bei Jing"} };
 
	//对第3个元素进行赋值
	s[2].number = 10002;
	s[2].sex = 'm';
	s[2].age = 22;
	strcpy(s[2].name,"Liu");
	strcpy(s[2].addr,"Guang Dong");
 
	//将上述3个元素输出到屏幕
	printf("%d,%s,%c,%d,%s\n",s[0].number,s[0].name,s[0].sex,s[0].age,s[0].addr);
	printf("%d,%s,%c,%d,%s\n",s[1].number,s[1].name,s[1].sex,s[1].age,s[1].addr);
	printf("%d,%s,%c,%d,%s\n",s[2].number,s[2].name,s[2].sex,s[2].age,s[2].addr);
	return 0;
}
```

### 结构体-指针

首先让我们定义结构体：

```c
struct stu
{
char name[20];
long number;
float score[4];
} ;
```

  再定义指向结构体类型变量的指针变量：

```c
struct stu *p1, *p2 ;
```

### 共用体类型

和结构体类似，也有共用体类型的定义、共用体变量的实例，数组、指针等

共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

- 共用体变量任何时刻只有一个成员存在；
- 共用体变量定义（实例化）时分配内存，长度=最大成员所占字节数。

### 枚举类型

枚举类型规定取值只能再提供的范围内，保证了数据取值的安全性。

**先定义枚举类型，再定义枚举变量**

```CQL
enum DAY  //定义枚举类型
{
      1, 2, 3, 4, 5, 6, 7
};
enum DAY day = 5;  //实例化，day的取值被限制。
```



## 标准库

C语言的标准文档要求了一个平台移植C语言的时候至少要实现的一些功能和封装的集合，称为“标准库”，标准库的声明头部通过[预处理器](https://zh.wikipedia.org/wiki/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)命令#include进行引用。

在C89标准中：

| 文件       | 简介说明                                                     |
| ---------- | ------------------------------------------------------------ |
| <assert.h> | 断言相关                                                     |
| <ctype.h>  | 字符类型判断                                                 |
| <errno.h>  | 标准报错机制                                                 |
| <float.h>  | 浮点运算                                                     |
| <limits.h> | 各种体系结构限制                                             |
| <locale.h> | 本地化接口                                                   |
| <math.h>   | 数学函数                                                     |
| <setjmp.h> | 跨函数跳转                                                   |
| <signal.h> | 信号（类似[UNIX](https://zh.wikipedia.org/wiki/UNIX)的[信号](https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7_(Unix))定义，但是差很远） |
| <stdarg.h> | 可变参处理                                                   |
| <stddef.h> | 一些标准宏定义                                               |
| <stdio.h>  | 标准I/O库                                                    |
| <stdlib.h> | 标准工具库函数                                               |
| <string.h> | ASCIIZ字符串及任意内存处理函数                               |
| <time.h>   | 时间相关                                                     |